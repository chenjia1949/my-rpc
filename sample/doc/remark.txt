init 函数
    1:每个包可以包含任意多个init函数，这些函数都会在程序执行开始的时候被调用。
    2:如果从程序主入口开始,某个.go文件始终不会被编译器编译,那么这个文件中的init函数是不会被执行的。
    所有被编译器发现的init函数都会安排在main函数之前执行。
    3:init函数用在设置包、初始化变量或其他要在程序运行前优先完成的引导工作。

数组：
    1:数组是一个长度固定的数据类型,用于存储一段具有相同类型的元素的连续块。
    2:数组是map和slice的基础数据结构。
    3:数组占用的内存是连续分配的。
    4:数组一旦申明，里边存储的数据类型和数组长度就都不能改变了。
      如果需要存储更多的元素，就需要先创建一个更长的数组，再把原来数组里的值复制到新的数组里。
    5:数组初始化时，数组内每个元素都初始化为对应类型的0值。
    6:例如 arr := [...]{1,2,3,4,5},如果使用 ... 替代数组的长度，go 语言会根据初始化时数组的元素个数来确定该数组的长度。
    7:在go中，数组是一个值，这意味着数组可以用在赋值操作中。变量名代表整个数组，因此，同样类型的数组可以赋值给另一个数组。
    8:数组变量的类型包括数组长度和每个元素的类型。只有这两部分都相同的数组，才是类型相同的数组，才能相互赋值。
    9:复制数组指针，只会复制指针的值，而不会复制指针所指向的值。
多维数组：
    1:数组本身只有一个纬度，不过可以组合多个数组创建多维数组。一般用来管理具有父子关系的数据或者与坐标系相关的数据。
    2:个人理解，数组中的元素还是数组，这样的结构构成多位数组。
在函数中传递数组
    1:为了减少不必要的内存复制操作，在函数间传递数组时可以使用指针进行传递。
    2:使用指针传递时会出现，指针所指向的内存地址中的数据被修改，导致数据不安全。

切片：
    1:切片是一种数据结构，这种数据结构便于使用和管理数据集合。
    2:切片是围绕动态数组的概念构建的，可以按需自动增涨和缩小。
    3:切片的动态增长是通过内置函数appen来实现。这个函数可以快速且高效的增长切片。也可以缩小一个切片，因为切片的底层内存也是连续分配的内存块。
    4:切片有三个内置参数;指针(指向底层数组)、长度(切片中元素个数)、容量(切片允许存放的最大元素个数)
    5:切片之所以称之为切片，就是因为创建一个新的切片就是把底层数组切出一部分。
    6:对底层数组容量是k的切片slice[i:j]来说;长度:j-i,容量:k-i
    7:切片在函数间的传递，切片在函数间的传递消耗很小，切片作为值来进行传递

map：
    1:map使用两个数据结构来存储数据。
      第一个数据结构是一个数组，内部存储的是用于选择桶的散列建的高八位值。这个数组用于区分每个键值对要存在哪个桶里。
      第二个数据结构是一个字节数组，用于存储键值对。该字节数组先依次存储了这个桶里所有的键，之后依次存储了这个桶里的所有值。
      实现这种键值对的存储方式目的在于减少每个桶所需的内存。
    2:map是一个存储键值对的无序集合。
    3:在函数间传递map时并不会制造出该map的一个副本。实际上，当传递map给一个函数时，并对这个map做了修改，所有对这个map的引用都会察觉到这个修改。
    4:当我们用make函数初始化切片时，如果不指明其容量，那么它就会和长度一致。如果在初始化时指明了容量，那么切片的实际容量也就是它了。
      make([]string,5,5);make([]string,5)

方法：
    1:值接收者使用值的副本来调用方法，而指针接收者使用实际值来调用方法。
    2:go语言既允许使用值，也允许使用指针来调用方法，不必严格符合接收者的类型。这个支持非常方便开发者编写程序。

类型的本质：
    在声明一个新类型之后，声明一个该类型的方法之前，需要先回答一个问题：
        这个类型的本质是什么？
            如果给这个类型增加或者删除某个值，是要创建一个新值，还是要更改当前的值？
            如果是要创建一个新值，该类型的方法就是用值接收者；如果是要修改当前值，就使用指针接收者。
    方法的声明会影响到程序内部传递这个类型的值的方式;是按值做传递，还是按指针做传递。保持传递的一致性很重要。

内置类型：
    内置类型是由语言提供的一组类型。分别是数值类型、字符串类型、布尔类型。这些类型本质上是原始类型。
    因此，当对这些值进行增加后者删除的时候，会创建一个新值。
    当把这些类型的值传递给方法或者函数时，应该传递一个对应值的副本。
引用类型：
    go语言中的引用类型;slice、map、channel、interface、function。
    从技术细节上说，string也是一种引用类型。每个引用类型创建的标头值是包含一个指向底层数据结构的指针。
    每个引用类型还包含一组独特的字段，用于管理底层数据结构。
    标头值是为复制而设计的，所以永远不需要共享一个引用类型的值。
    标头值里包含一个指针，因此通过复制来传递一个引用类型的值的副本，本质上就是在共享底层数据结构。
结构体类型：
    结构体类型可以用来描述一组数据值，这组值的本质即可以是原始的，也可以是非原始的。
    如果决定在某些东西需要删除或者添加某个结构类型的值时，该结构类型的值不应该被更改，
    那么需要遵守之前提到的内置类型和引用类型的规范。
接口：
    1:多态是指代码可以根据类型的具体实现采取不同行为的能力。
      如果一个类型实现了某个接口，所有使用这个接口的地方，都可以支持这种类型的值。
    2:方法集;方法集定义了一组关联到给定类型的值或者指针的方法。定义方法时使用的接收者的类型决定了这个方法是关联到值，还是关联到指针，还是两个都关联。
嵌入类型： (对应java中的内部类)
    go语言允许用户扩展或者修改已有类型的行为。这个功能对代码复用很重要，在修改已有类型以符合新类型的时候也很重要。这个功能通过嵌入类型完成的。
    嵌入类型是将已有的类型直接在新的结构类型里。被嵌入的类型被称为新的外部类型的内部类型。

公开或未公开的标识符
    1:当一个标识符的名字以小写字母开头时，这个标识符就是未公开的，即包外的代码不可见。
    2:当一个标识符的名字以大写字母开头时，这个标识符就是公开的，即被包外的代码可见。

并发：
    1:go里的并发指的是能让某个函数独立于其他函数运行的能力。当一个函数创建为goroutine时，go 会将其视为一个独立的工作单元。
      这个单元会被调度到可用的逻辑处理器上执行。go语言运行时的调度器是一个复杂的软件，能管理被创建的所有goroutine并为其分配执行时间。
      这个调度器在操作系统之上，将操作系统的线程与语言运行时的逻辑处理器绑定，并在逻辑处理器上运行goroutine。
      调度器在任何给定的时间，都会全面控制哪个goroutine要在哪个逻辑处理器上运行。
    2:go语言的并发同步模型来自一个叫作通信顺序进程的范型(CSP);csp是一种消息传递模型，通过在goroutine之间传递数据来传递消息，
      而不是对数据进行加锁来实现同步访问。用于在goroutine之间同步和传递数据的关键数据类型叫做channel。
    3:基于调度器的内部算法，一个正在运行的goroutine在工作结束前，可以被停止并重新调度。调度器这样做的目的是防止某个goroutine长时间占用逻辑处理器，
      并给其他可运行的goroutine运行的机会。
竞争条件：
    1:如果两个或多个goroutine在没有互相同步的情况下，访问某个共享的资源，并试图同时读和写这个资源，就处于相互竞争的状态，这种情况被称作为竞争状态。
      竞争状态的存在是让并发程序变得复杂的地方，十分容易引起潜在问题。对一个共享资源的读和写操作必须是原子化的。换句话说，同一时刻只能有一个goroutine对共享资源进行读和写操作。
互斥锁：
    1:互斥锁这个名字来自互斥的概念。互斥锁用于在代码上创建一个临界区，保证同一时刻只有一个goroutine可以执行这个临界区代码。
    2:在go中可以通过，原子函数、互斥锁、通道来保证共享资源的安全操作。
通道：
    1:当一个资源需要在goroutine之间共享时，通道在goroutine之间架起一个管道，并提供了确保同步交换数据的机制。
      声明通道时，需要指定将要被共享的数据的类型。可以通过通道共享内置类型、命名类型、结构类型和引用类型的值或者指针。
    2:无缓冲的通道是指在接收前没有能力保存任何值的通道。这种类型的通道要求发送goroutine和接收gotoutine同时准备好，才能完成发送和接收操作。
      如果两个goroutine没有同时准备好，通道会导致先执行发送或接收操作的goroutine阻塞等待。
      这种对通道进行发送和接收的交互行为本身就是同步的。其中任意一个操作都无法离开另一个操作独立存在。
    3:有缓冲的通道是一种在被接收者接收前能存储一个或多个值的通道。这种类型的通道并不强制要求goroutine之间必须同时完成发送和接收。
      通道会阻塞发送和接收动作的条件也会不同。只有在通道中没有要接收的值时，接收动作才会阻塞。这导致有缓冲的通道和无缓冲的通道之间的一个很大不同;
      无缓冲的通道保证进行发送和接收的goroutine会在同一时间进行数据交换;
      有缓冲的通道没有这种保证。
    